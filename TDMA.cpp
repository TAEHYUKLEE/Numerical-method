# include <stdio.h>
//Tridagonal Matrices 6.17 HW

double x[10];
double a[10] = {0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
double b[10] = {-4.0, -4.0, -4.0, -4.0, -4.0, -4.0, -4.0, -4.0, -4.0, -4.0};
double c[10] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0};
double d[10] = {-27.0, -15.0, -15.0, -15.0, -15.0, -15.0, -15.0, -15.0, -15.0, -15.0}; 
                                    // Row로 배열을 잡을 경우 일반 Gauss-Elimination 처럼 모두 계산을 해야하기 때문에 크게 이득이 없다. 
                                   // 결국 a, b, c로 각 각 Diagonal을 잡고 이걸로 일반화시켜서 계산량을 줄이도록 한다. 

int main(void)
{
	int i, j, k, n;
	double f;
	n=9;
	
	for(i =0; i<n; i++) //i=1부터 시작 1-row는 아무 상관없다 2-row부터 밑의 항들 싹다 제거하는 것이기 때문에 
	{
		f= a[i]/b[i-1];
		
		a[i] = a[i] -b[i-1]*f; //사실상 0이기때문에 보통 C++ 코딩할때는 안쓴다.   (생략가능) 
		b[i] = b[i] -c[i-1]*f; //원래 Gauss Elimination에서는 for (k)문을 이용하여 Coulumn을 옮겨다니며 전체를 다 operation했지만 여기서는 
		                      // 하나의 element밖에 없기때문에 수동!
		c[i] = c[i] - 0*f;     // 위의 항이 0이기때문에 사실 new ci =그냥 ci이이다. 이것도 진짜 코딩할때는 안써도 된다  (생략가능) 
		d[i] = d[i] - d[i-1]*f;  //마지막 해의 부분 구하기  
	 } 
	 //여기까지해서 Main diagonal 아랫부분을 모두 0으로 만들었다
	//여기서부터는 Gauss-elimination하고 똑같이 아래서부터 연산하여 올라간다.  
	
	x[n] = d[n]/b[n]; //맨 아래 항의 해를 구한다
	
	for(i=n; i>=1; i--) //맨 아래 행부터 위로 올라가기때문에 n-1로 시작한다 
	{
		x[i]= (d[i]-c[i]*x[i+1])/b[i]; //Gauss elimination같은경우는 옆에 항들이 많았기때문에 for문을 이용하여 옆의 항들을 다 sum으로 더한후 
		                           //계산을 했지만 여기에서는 c[i]가 하나기때문에 이렇게 가능하다 main diagonal은 x[i]와 결합되고 그 옆의 
								   //c[i]는 그 다음 x값인 x[i+1]과 결합됨을 유의하자. 
	}
	 
	 // 주의! (d[i]-c[i]*x[i+1])/b[i]; 내가 틀렸었던 부분 ()빼 먹어서 맨 아래항빼고 나머지 계산이 다 틀렸었다. 
	 
	//이렇게 모든 x값들을 구하였고 이제 출력만 하면된다.
	
	for(i=0; i<=n; i++)
	{
		printf("x=%f \n", x[i]);
	 } 
	
			
	return 0;
}
